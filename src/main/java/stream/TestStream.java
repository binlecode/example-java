package stream;

import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.util.stream.Collectors.counting;

public class TestStream {

    public static void main(String[] args) throws URISyntaxException, IOException {

        // consumer with double functional input
        BiConsumer<Integer, String> csm2 = (i, n) -> System.out.println("" + n + " element: " + i);

        // ** and, you DON'T have readily available consumer (from jdk) with > 2 input support ... **

        List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6);  // list generated by Arrays.asList() is immutable!

        lst.forEach(i -> csm2.accept(i, "List lst"));

        // Stream operations donâ€™t mutate their source. Instead, they return new streams that hold the result
        lst.stream()
                .filter(i -> i > 3)
                .collect(Collectors.toList())
                .forEach(i -> csm2.accept(i, "filtered lst"));

        System.out.println(lst.stream().filter(i -> i > 3).findAny().get());

        Stream<Integer> iStrm = lst.parallelStream();
        // got Optional.empty
        Integer intResult = iStrm.filter(i -> i > 4).filter(i -> i < 3).findAny().orElse(-1);
        System.out.println(intResult);

        Stream<String> sStrm = Stream.of("this is a sample text string".split(" "));

        sStrm.sorted().forEach(s -> System.out.println("s = " + s));

        // use iterator to generate stream
        Stream.iterate(1, n -> n + n).limit(10)
                .forEach(i -> System.out.println("i = " + i));


        // *** NIO.2 File and Path examples with Stream API ***

        // use nio.Files to get a file from resource path
        Path path = Paths.get(TestStream.class.getClassLoader()
                .getResource("test_csv_2_html.csv").toURI());

        List<String> linesCopy = new ArrayList<>();

        Files.lines(path)
                .filter(line -> line.contains("ok"))
                .peek(line -> {   // peek doesn't consume the element from the stream
                    System.out.println("filtered original line = " + line);
                    linesCopy.add(line);
                })  // peek is like branching/logging
                .map(line -> line.split(",")[3])  // get the number from last column
                .forEach(line -> System.out.println("filtered value = " + line));

        linesCopy.forEach(System.out::println);

        Files.lines(path)
                // Stream.sorted returns a new sorted stream
                .sorted(Comparator.comparing(s -> -1 * Double.parseDouble(s.split(",")[3])))  // reverse value sort
                .forEach(line -> System.out.println("sorted line = " + line));


        // use Double::sum as reducer function to get overall sum
        Double sum = Files.lines(path)
                .map(line -> Double.parseDouble(line.split(",")[3]))
                .reduce(0d, Double::sum); // if stream is empty, then return 0d
        System.out.println("sum = " + sum);

        // use map collector to transform list to map with dup key resolving
        Map r = Files.lines(path)
                .map(line -> line.split(","))
                .collect(Collectors.toMap(
                        elm -> elm[0],
                        elm -> elm[3],
                        (x, y) -> {
                            System.out.println("dup keys found, retaining existing one");
                            return x;
                        },
                        TreeMap::new // customize map supplier
                ));
        System.out.println("r = " + r);

        // use groupBy with a Function (by lambda) to collect a map by lambda customized key

        // use the 4-th column for the grouping key
        Function<String, String> getGroupingKey = str -> str.split(",")[3];

        Map<String, List<String>> rm = Files.lines(path)
                .collect(Collectors.groupingBy(getGroupingKey));
        rm.keySet().forEach(k -> System.out.println("k = " + k + ", v = " + rm.get(k)));

        Map<String, Long> rc = Files.lines(path)
                .collect(Collectors.groupingBy(getGroupingKey, counting()));
        rc.keySet().forEach(k -> System.out.println("k = " + k + ", count = " + rc.get(k)));


    }
}
